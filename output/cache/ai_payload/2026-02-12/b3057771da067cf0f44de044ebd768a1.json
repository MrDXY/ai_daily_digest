{
  "url": "https://www.tuhs.org/pipermail/tuhs/2020-August/022108.html",
  "payload": {
    "title": "Functional programming in m4 (2020)",
    "content": "[TUHS] bare m4 (was BTL summmer employees)\nDoug McIlroy\ndoug at cs.dartmouth.edu\nSat Aug 22 13:29:50 AEST 2020\n>\n>> Even high-school employees could make lasting contributions.  I am\n>\n>> indebted to Steve for a technique he conceived during his first summer\n>\n>> assignment: using macro definitions as if they were units of associative\n>\n>> memory. This view of macros stimulated previously undreamed-of uses.\n>\n>\n> Can you give some examples of what this looked like?\n>\nSee attached for an answer to Arnold's question\n\nDoug\n-------------- next part --------------\ndefine(_,`dnl')_  unobtrusive dnl, used for readability\n_\n_ m4 is Turing complete even when stripped to the bare minimum\n_ of one builtin: `define'. This is not news; Christopher Strachey\n_ demonstrated it in his ancestral GPM, described in \"A general\n_ purpose macrogenerator\", The Computer Journal 8 (1965) 225-241.\n_\n_ This program illustrates the fact by implementing bit-by-bit\n_ binary arithmetic, systematically employing some unusual m4\n_ idioms, used in largely functional style:\n_\n_  1. Case-switching via macro names constructed on the fly.\n_  2. Representing data structures by nested parenthesized lists.\n_  3. Using macros as named places to store data.\n_\n_ A case switch (Idiom 1)\n_\n_ An essential feature of programming is conditional execution.\n_ Suppose there are predicates that yield `T' or `F' for true\n_ or false. A conditional switch of the form\n_\n_    if(<T or F>,`<T action>', `<F action>')\n_\n_ constructs calls for `if_T, or `if_F' that select the\n_ appropriate action:\n_\ndefine(if,`if_$1(`$2',`$3')')_\ndefine(if_T,`$1')_\ndefine(if_F,`$2')_\n_\n_ Example\n_\n_    if(T,`yes',`no') => if_T(`yes',`no') => yes\n_    if(F,`yes',`no') => if_F(`yes',`no') => no\n_\n_ Basic Boolean functions are easy to define in terms of `if':\n_\ndefine(not,`if($1,`F',`T')')_\ndefine(and,`if($1,`$2',`F')')_\ndefine(or,`if($1,`T',`$2')')_\ndefine(xor,`if($1,`not($2)',`$2')')_\n_\n_ List representation (Idiom 2)\n_\n_ In order to provide access to individual members, sequences\n_ of data values may be represented as right-associated lists.\n_ In particular, binary integers may be represented in this\n_ manner:\n_\n_    (1,(0,(1,(1,()))))\n_\n_ To facilitate arithmetic algorithms, the presentation\n_ is little-endian. In customary base-2 notation the\n_ example becomes 1101 (decimal 13). An empty list `()' acts\n_ as terminator. Non-significant 0's (leading zeros in\n_ customary notation) are not allowed;\n_ the value zero is represented by the empty list.\n_\n_ Macros as named storage (Idiom 3)\n_\n_ Example\n_\n_    define(thirteen,`(1,(0,(1,(1,()))))')_\n_\n_ Individual list elements may be accessed by a pun, in which\n_ the outer parentheses of a list are taken to be the\n_ argument-list delimiters in a macro call. Two basic macros\n_ use this schem to extract \"head\" and \"tail\" parts, <h>\n_ and <t>, from a nonempty list:\n_\n_    head((<h>,<t>)) ==> <h>\n_    tail((<h>,<t>)) ==> <t>\n_\ndefine(head,`_head$1')_\ndefine(_head,`$1')_\n_\ndefine(tail,`_tail$1')_\ndefine(_tail,`$2')_\n_\n_ Example\n_\n_    head(thirteen) ==> _head(1,(0,(1,(1,()))))  => 1\n_    tail(thirteen) ==> _tail(1,(0,(1,(1,())))) => (0,(1,(1,()))\n_\n_ (In showing the progress of macro expansion => denotes a single\n_ step; ==> denotes multiple steps.)\n_\n_ According to the rules of m4, `head' and `tail' also work on\n_ the empty list, `()',in which case either function yields an\n_ empty string, `'. This property of `head' will be exploited.\n_\n_ A digit-equality test, `eqd', is useful in arithmetic. It\n_ switches on two arguments chosen from the set {`', `0', `1'}\n_ and yields `T' or `F' according as they are or are not equal.\n_ The \"digit\" `' arises from expressions such as `head(())'.\n_ The macro switches on its two arguments in the same way that\n_ `if' switches on one argument.\n_\ndefine(eqd,`eqd_$1_$2()')_\ndefine(eqd__,`T')_\ndefine(eqd__0,`F')_\ndefine(eqd__1,`F')_\n_\ndefine(eqd_0_,`F')_\ndefine(eqd_0_0,`T')_\ndefine(eqd_0_1,`F')_\n_\ndefine(eqd_1_,`F')_\ndefine(eqd_1_0,`F')_\ndefine(eqd_1_1,`T')_\n_\n_ Example\n_\n_    eqd(1,0) => eqd_1_0() => F\n_\n_ The () appended by `eqd' is defensive. If () were\n_ omitted, then <text> would mistakenly be eaten in a\n_ rare juxtaposition like\n_\n_    eqd(1,0)(<text>) => eqd_1_0(<text>) => F\n_\n_ The easiest arithmetic function is the successor function.\n_ It can be programmed entirely in terms of functions\n_ already defined. (The name `Succ' is capitalized to\n_ distinguish it from a different implementation that\n_ will soon be described.)\n_\ndefine(Succ,`if(eqd(head($1),`'),`(1,())','_\n``if(eqd(head($1),`0'),`(1,tail($1))',`(0,Succ(tail($1)))')')')_\n_\n_ (Right and left quotes before and after `_' bring it to top\n_ level to keep it out of the text of `Succ'.)\n_\n_ `Succ' ultimately expands in one of three different ways,\n_ each presented in a different context: the first alternative\n_ of an `if', the first alternative of a nested `if', and the\n_ second alternative of an `if'. It would be notionally\n_ cleaner to use a 3-way switch.\n_\n_ Unfortunately, overt switch code relies on Idiom 1, a glaring\n_ deviation from the mainstream functional style employed in\n_ `Succ'. Fortunately, a remedy is at hand: macros that hide\n_ the idiom.\n_\n_ A general pattern for switching on the head of the operand of\n_ a unary operation, <op>, is\n_\n_    define(<op>,`_<op>(head($1))($1)')_\n_    define<_<op>,`<op>_$1')_\n_\n_ The pattern is hidden once and for all in the macro\n_ `cases1(<op>)'.\n_\ndefine(cases1,`_cases1(dol(1),`$1')')_\ndefine(_cases1,`define($2,`_$2(head($1))($1)')_\ndefine(_$2,`$2_$1')')_\ndefine(dol,`$$1')_\n_\n_ The magic here is the \"dollar macro\"\n_\n_    dol(1) => $1\n_\n_ which results in `$1' being substituted for `$1' [sic] throughout\n_ the replacement text of `_cases1', while <op> is substituted for\n_ `$2'. When <op> is `succ', the expansion proceeds thus:\n_\n_    cases1(succ) => _cases1(dol(1),`succ') =>\n_    define(succ,`_succ(head($1))($1)')define(_succ,`succ_$1')\n_\n_ Code for individual cases of the successor function remains\n_ to be supplied.\n_\ncases1(succ)_\ndefine(succ_,`(1,())')_\ndefine(succ_0,`(1,tail($1))')_\ndefine(succ_1,`(0,succ(tail($1)))')_\n_\n_ Example\n_\n_    succ((1,()) => _succ(1,())((1,())) => succ_1((1,())) =>\n_    (0,succ(tail((1,())))) ==> (0,succ(()) ==> (0,(1,()))\n_\n_ Some small constants may be defined for future use (Idiom 3).\n_\ndefine(zero,())_\ndefine(one,succ(zero))_\ndefine(two,succ(one))_\n_\n_ Here is a pretty-print macro that converts binary numbers\n_ in list form to ordinary binary notation.\n_\ndefine(base2,`if(eqd(head($1),`'),`0',`_base2($1)')')_\ncases1(_base2)\ndefine(_base2_,`')_\ndefine(_base2_0,`_base2(tail($1))0')_\ndefine(_base2_1,`_base2(tail($1))1')_\n_\n_ Example, with `thirteen' as given in a previous example\n_\n_    base2(zero) ==> 0\n_    base2(thirteen) ==> 1101\n_\n_ A counter based on `succ' may be held in a macro whose content may\n_ be updated by a macro`incr' or read out simply by expanding it.\n_\ndefine(incr,`define(`$1',succ($1))')_\n_\n_ Example\n_\n_    define(mycounter,())\n_    incr(`mycounter')\n_    incr(`mycounter')\n_    base2(mycounter) => 10\n_\n_ Binary operations may be defined by switching on two\n_ parameters. The switching code, generated by a macro\n_ `cases2', is very like that generated by `cases1' with\n_ two calls of the dollar macro instead of one.\n_\ndefine(cases2,`_cases2(dol(1),dol(2),$1)')_\ndefine(_cases2,`define($3,`_$3(head($1),head($2))($1,$2)')_\ndefine(_$3,`$3_$1_$2')')_\n_\n_ Now comes addition of binary numbers\n_\ncases2(add)_\ndefine(add__,zero)_\ndefine(add__0,`$2')_\ndefine(add__1,`$2')_\ndefine(add_0_,`$1')_\ndefine(add_0_0,`(0,add(tail($1),tail($2))')_\ndefine(add_0_1,`(1,add(tail($1),tail($2))')_\ndefine(add_1_,`$1')_\ndefine(add_1_0,`(1,add(tail($1),tail($2))')_\ndefine(add_1_1,`(0,add(tail($1),succ(tail($2))))')_\n_\n_ Further arithmetic operations like multiplication, power,\n_ and comparisons can be programmed similarly, as can a\n_ a division operator that yields a (quotient,remainder)\n_ pair.\n_\n_ Definitions of operations need not switch on all arguments.\n_ This boringly similar macro provides the switch for\n_ a function that switches on the second of two arguments:\n_\ndefine(cases2of2,`_cases2of2(dol(1),dol(2),$1)')_\ndefine(_cases2of2,`define($3,`_$3(head($2))($1,$2)')_\ndefine(_$3,`$3_$1')')_\n_\n_ A higher-level switch-generator might take the form\n_\n_    cases(<op>,<switchparms>,<parms>)\n_\n_ where <switchparms> is a list of parameter numbers to\n_ switch on, and <parms> is a list of all parameter numbers.\n_ Then cases2of2 would be definable without messing with\n_ the dollar macro:\n_\n_    define(case2of2,`cases(<op>,(2,()),(1,(2,())))')\n_\n_ Other data types\n_\n_ The basic list-processing operations, head and tail, are\n_ agnostic about the content of lists. Head values can\n_ come from any set, for example alphanumeric characters.\n_ In principle a string-equality operator declared\n_ by `cases2(eqs)' could be programmed to yield `T' or\n_ `F' for examples like\n_\n_    eqs((W,(O,(R,(D,(1,()))))),(W,(O,(R,(D,(2,())))))\n_\n_ but it would require a daunting N^2 = 3969 case macros,\n_ where N counts uppercase, lowercase and numeric characters\n_ plus the empty character. Fortunately there is a trick\n_ that reduces the number of case macros to N = 63.\n_\n_ For every character <c> define a case macro `eqc_<c>' to\n_ yield `F'. Here's a small sample:\n_\ndefine(eqc_A,`F')_\ndefine(eqc_B,`F')_\ndefine(eqc_C,`F')_\ndefine(eqc_D,`F')_\ndefine(eqc_,`F')_\n_\n_ Then `eqc(<a>,<b>)' redefines `eqc_<a>' to yield `T' and\n_ calls `eqc_<b>'. The result is `T' only if <a> and <b> are\n_ the same. Finally `eqc' restores the definition of `eqc_<a>'.\n_ The only subtlety in the definition of `eqc' is the empty\n_ quotes that keep the result of `eqc_$2' from being tacked\n_ onto `define':\n_\ndefine(eqc,`define(`eqc_$1',`T')eqc_$2`'define(`eqc_$1',`F')')_\n_\n_ In terms of `eqc' string-comparison becomes\n_\ndefine(eqs,`if(eqc(head($1),`'),`T',`if(eqc(head($1),head($2)),'_\n``eqs(tail($1),tail($2))',`F')')')_\n_\n_ One might hope to automate the writing of case definitions\n_ for `eqc' by iterating over a list like\n_\n_    (A,(B,(C,(D,())))\n_\n_ The hope is apparently vain: to identify the end of the list\n_ one needs a case switch over the set of elements that may\n_ appear in the list--infinite regress. I know of no workaround\n_ much less laborious than writing out all the cases directly.\n_\n_ Universality\n_\n_ It's not hard to envision simulating a simple computer, except\n_ for interactive input-out--a deficiency that is shared with\n_ Turing machines. Thus, aside from resource limitations, bare\n_ m4 is Turing complete.\n_\n_ The program counter is maintained by `incr', and converted\n_ to string form by `base2'.\n_\n_ The <n>th word of memory is a binary number held in a macro\n_ named W<n>, where <n> is expressed in string form.\n_.\n_ Operation codes are a limited set of binary numbers <op>, and\n_ may be switched on by converting them to string form I<op>.\n_\n_ A branch operation redefines the location counter.\n_\n_ An assignment redefines the designated word.\n_\n_ Other operations are coded in styles illustrated above.\n_\n_ Words need not be limited in size. Numbers may be kept\n_ in sign-magnitude form.\n_\n_ Instructions may be of variable length--one word of opcode,\n_ and following words of addresses or immediate operands.\n_\n_ A control macro fetches an opcode according to the location\n_ counter.  If the opcode is a halt instruction, the control\n_ terminates. Otherwise it calls the designated operation,\n_ updates the instruction counter according to the opcode,\n_ and calls the control recursively.\n_\n_ Advice for m4\n_\n_ Recursion of the control macro is unlimited and unavoidable.\n_ Ufortunately few, if any, m4 implementations implement tail\n_ calls so as not to grow the program stack. Doing so would\n_ help this and other deeply recursive applications.\n_\nMore information about the TUHS\nmailing list",
    "description": "",
    "id": null,
    "short_id": null,
    "url": "https://www.tuhs.org/pipermail/tuhs/2020-August/022108.html",
    "score": "16",
    "tags": "unix",
    "domain": "tuhs.org",
    "author": "fanf",
    "author_url": "fanf",
    "time": "12 hours ago",
    "comments_text": "no comments",
    "comments_url": "no comments",
    "description_hint": null
  },
  "cached_at": "2026-02-12T05:05:35.817947"
}