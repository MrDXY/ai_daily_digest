{
  "url": "https://www.nhplace.com/kent/Papers/Technical-Issues.html",
  "payload": {
    "title": "Technical Issues of Separation in Function Cells and Value Cells (1988)",
    "content": "Technical Issues of Separation in Function Cells and Value Cells\nThis paper appears in\nLisp and Symbolic Computation\n, Volume 1, No. 1, June 1988, pp81-101.\nThe substance of the original text appears in normal fonting,\nthough a small number of out-and-out typos were corrected.\nOddities of spelling that were the custom of the time\n(either generally, or just for me) were left alone.\nSome formatting of headings and tables was adjusted slightly for HTML.\nAny new text that has been added appears\nbracketed and in color green; such text is intended to\nhelp clarify the historical context, since considerable time\npassed between the time this paper was published and the time I\nconverted it to HTML.\nSpecial thanks to Stephanie Peteranecz for bringing the text of this paper\nback online after its original source had been lost.\n—\nKent Pitman\n, 06-Feb-2001\nPLEASE NOTE:\nThis was a very technically detailed paper to transcribe\nand proofread.  If you see any text that does not make sense or looks like\na typo, please\nsend Kent e-mail\n.\nAnnotated original document follows.\nClick here for an index\nof other titles by Kent Pitman.\nby\nRichard P. Gabriel\n[address at time of publication]\nLucid, Inc. and Stanford University\n[address at time of publication]\nKent M. Pitman\nSymbolics, Inc.\n1. Preface\nThis paper is an adaptation of a report produced for X3J13 by the\nauthors, a technical working group engaged in standardizing Common\nLisp for ANSI\n2. Introduction\nIn 1981 the emerging Common Lisp community turned to Scheme for some of\nits motivation and inspiration\n[Steele 1984]\n.  Adopting lexical scoping proved one of the most important decisions the Common Lisp\ngroup ever made.\nOne aspect of Scheme that was not adopted, however, was a single\nnamespace for functions and values, along with uniform evaluation\nrules for expressions in function and argument positions within the\nlanguage.  At the 1986 ACM Conference on Lisp and Functional\nProgramming, members of a part of the European Lisp community (called\nthe EuLisp group) involved in the design of a Lisp dialect suggested\nthat Common Lisp should have adopted this paradigm and that it might\nstill be appropriate to do so.\nMany people in the Common Lisp community were unhappy about the\nproposed change.  Technical, philosophical, and political arguments on\nboth sides of the issue became quickly apparent.  Since the issue is\ncontroversial, the Common Lisp community felt that the technical\nissues should be clearly documented before any decision was attempted.\nThis paper addresses those technical issues.\n3. Notation and Terminology\nWe shall begin by establishing some standard terminology.  Some\nreaders may wish to skip this section and refer to it only if a\nquestion arises about some term.\nA\nfunction\nis anything that may correctly be given to the\nFUNCALL\nor\nAPPLY\nfunction and is to be executed as code when arguments are\nsupplied.  A nonfunction is any other Lisp object.\nAn\nidentifier\nis the name of a symbol or a variable.  This is not an\nexclusive partition: a variable can be a symbol.  An identifier is\nessentially a print name.\nA\nsymbol\nis a Lisp data structure that has a value cell, a property\nlist, a function cell (in Common Lisp), and so on.\nA\nvariable\nis an identifier that names a location\nA\nbinding\nis a pairing of an identifier with a location in which a\nLisp object may be placed.\nA\nlexical variable\nis a binding in which the identifier is not taken\nto refer to a symbol.  A symbol with a value in its value cell is\ntaken to be a binding in that the name of the symbol is paired with\nthe value cell of the symbol.  A\nspecial variable\nis a binding in\nwhich the identifier is taken to refer to a symbol.\nAn\nenvironment\nis the set of all bindings in existence at some\ngiven time.  We shall call a subset of an environment a\nsubenvironment\n.\nA\nnamespace\nis a subenvironment.  Often the location parts of the\nbindings in a namespace contain objects used for some purpose, and the\nidentifiers of the namespace are said to \"name objects\" used for that\npurpose; if the types of objects that can be stored in the location\nparts of bindings in a namespace are used for a purpose such that only\nobjects of a certain type can be used for that purpose, then we say\nthat \"the objects in the namespace are restricted\" to that type of\nobject.  The objects that are stored in the location parts of bindings\nin a namespace are not necessarily restricted to first-class Lisp\nobjects.  In this paper, there are two namespaces of concern, which we\nshall term the \"value namespace\" and the \"function namespace.\" Other\nnamespaces include tag names (used by\nTAGBODY\nand\nGO\n)\nand block names\n(used by\nBLOCK\nand\nRETURN-FROM\n),\nbut the objects in the location parts\nof their bindings are not first-class Lisp objects.\nThe\nvalue namespace\nis a subenvironment whose location parts are not\nrestricted to any particular kind of object.  The purpose of this\nnamespace is to associate values with variables when those variables\noccur in certain textual contexts.  The binding of an identifier\nreferring to a symbol along with a value cell is in the value\nnamespace.  Lexical variables, such as those introduced by\nLET\n,\nLAMBDA\n, and\nMULTIPLE-VALUE-BIND\n, are in the value namespace.\nThe\nfunction namespace\nis a subenvironment whose purpose is to\nassociate functions with variables when those variables occur in\ncertain textual contexts.  We assume that the location parts of a\nfunction namespace always contain functions.  The binding of an\nidentifier referring to a symbol along with a function cell is always\nin the function namespace. Functional lexical variables, such as those\nintroduced by\nFLET\n,\nLABELS\n, and\nMACROLET\n, are in the function\nnamespace.\nLisp's evaluation rules tell, given an expression and an environment,\nhow to produce a value or values and a new environment.  In order to\ndo this, the meanings of identifiers in a program text need to be\ndetermined, and this requires determining in which namespace to\ninterpret the identifiers.  For example, a symbol can have something\nin its value cell and something else in its function cell; which of\nthese objects is referred to by the symbol in a piece of code depends\nupon which namespace is defined to be used for the context in which the\nsymbol appears.\nThe function and value namespaces are distinct in Common Lisp because,\ngiven a single name, the function namespace mapping and the value\nnamespace mapping can yield distinct objects.  The two mappings might\nyield the same object, but that would be mere coincidence.\nIn this paper, we shall refer to two abstract dialects of Lisp called\nLisp\n1\nand\nLisp\n2\n.\nLisp\n1\nhas a single namespace that serves a dual role as the function\nnamespace and value namespace; that is, its function namespace and\nvalue namespace are not distinct.  In\nLisp\n1\n, the functional position\nof a form and the argument positions of forms are evaluated according\nto the same rules.  Scheme\n[Rees 1986]\nand the language being designed\nby the EuLisp group\n[Padget 1986]\nare\nLisp\n1\ndialects.\nLisp\n2\nhas distinct function and value namespaces.  In\nLisp\n2\n, the rules\nfor evaluation in the functional position of a form are distinct from\nthose for evaluation in the argument positions of the form.  Common Lisp\nis a\nLisp\n2\ndialect.\n4. Historical Perspective\nMost Lisp dialects adopted a two-namespace approach to the naming\nproblem.  To some extent this is because most dialects followed Lisp\n1.5\n[McCarthy 1965]\nor dialects derived from Lisp 1.5\nLisp 1.5 broke symbols into values and functions; values were stored\non an association list, and function on the property lists of symbols.\nCompiled and interpreted code worked in different ways.  In the\ninterpreter, the association list was where all bindings were kept.\nWhen an identifier was encountered (an 'atomic symbol' in Lisp 1.5\nterminology), it was taken as a variable to be evaluated for its\nvalue.  First the\nAPVAL\npart of the symbol was interrogated—an\nAPVAL\nwas \"\nA\nP\nermanent, system-defined\nVAL\nue\"\nstored in a specific place in the symbol.\nSecond, the association list was searched.  Finally,\nif no binding was found, an error was signaled.\nWhen a combination was encountered, the function position was\nevaluated differently from other positions.  First, the symbol was\ninterrogated to see whether there was a function definition associated\nwith it; then the association list was searched.\nHere we can see two namespaces at work, though nonsymbol variables were\ntreated somewhat uniformly (Lisp 1.5 did not have lexical variables in\ninterpreted code): when there were no function definitions associated\nwith a symbol, there was one namespace, which was explicitly\nrepresented by the association list.\nCompiled code worked a slightly different way, and from its internals\nwe can see where the two namespaces came about in descendants of\nLisp 1.5.\nThe Lisp 1.5 compiler supported 'common' and 'special' variables.  A\ncommon variable enabled compiled and interpreted code to communicate\nwith each other.  A common variable was bound on an explicit\nassociation list; to evaluate such a variable, a call to EVAL was\nemitted to determine the value.  A special variable was the compiler's\nmodeling of free variables and closely matched what is now called\n'shallow binding.'  Ordinary variables compiled into what we have\ntermed lexical variables.\nThus, we see all of the components of the two-namespace world in\nLisp 1.5, along with some of the components of the one-namespace\nworld.\nIt seems that the designers of Lisp 1.5 thought of function names as\nbeing different from variable names—the Lisp 1.5 interpreter looked\nat the property list of the named atomic symbol first, and so it can\nbe argued that a function was considered a property of a symbol.  The\ndesigners used the terminology that a symbol \"stands for\" a function\nwhile a variable \"refers\" to a value.\nLisp for the PDP-6 at MIT adopted the style of the Lisp 1.5 special\nvariables for dynamic binding in both compiled and interpreted code,\nthereby eliminated common variables.  Compilers were still written\nthat were to try to interpret special variables as lexical variables\nin as many places as possible.  The value of a symbol was stored in\nthe value cell of the symbol, and the function remained on the\nproperty list as it did in Lisp 1.5.\nMacLisp\n[Pitman 1983]\nis a direct descendant of the PDP-6 Lisp and is\na\nLisp\n2\ndialect.  MacLisp uses a sophisticated form of link table,\nwhich is made possible by the separation of namespaces. In particular,\nfunction-defining functions have controlled access into the places\nwhere functions are stored so that the link tables can be correctly\nmaintained.\nVax NIL is a descendant of MacLisp and was intended to be the\nsuccessor to MacLisp running on the Vax.  It uses the same sort of\nlink table ideas found in MacLisp for fast function calling.  The\ndesigners of MacLisp and NIL had performance in mind when they\ndesigned the two-namespace layout.  A description of Vax NIL can be\nfound in\n[Gabriel 1985]\n.\nS-1 Lisp\n[Brooks 1982]\nis a dialect of NIL for the S-1 Mark IIA, and\ntherefore it is a\nLisp\n2\ndialect.  Spice Lisp is an intellectual\ndescendant of MacLisp and thus is a\nLisp\n2\ndialect.  A description of\nSpice Lisp can be found in\n[Gabriel 1985]\n.  ZetaLisp\n[Symbolics 1986b]\nis an intellectual descendant of MacLisp and, for reasons like those\nthat motivated the NIL designers, became a\nLisp\n2\ndialect.\nCommon Lisp was the result of a compromise between a number of\ndialects of Lisp, most of them descendants of MacLisp, all of them\nLisp\n2\ns.  A major aspect of the Common Lisp movement was compromise\nalong political lines.\n5. Notational Simplicity\nMany believe that having the evaluation rules for expressions treat\nthe function position and the argument positions differently is\ninelegant.  In\nLisp\n2\ndifferent treatment of functional and argument\npositions is needed because there are different namespaces or\nenvironments, for function bindings and for value bindings.\nLisp\n2\nis slightly more complicated than\nLisp\n1\nin situations where we\nwould want to do either of the following:\nFetch the value of an identifier in the value namespace and call it as a function\nFetch the value of an identifier in the function namespace and pass it around as a value.\nTo use the value of an identifier in the value namespace as a function,\nLisp\n2\nprovides this\nnotation:\n(FUNCALL <identifier> . <arguments>)\nFor example, in\nLisp\n2\none would write\n(DEFUN MAPC-1 (F L) (DOLIST (X L) (FUNCALL F X)))\nIn\nLisp\n1\n, one would write\n(DEFUN MAPC-1 (F L) (DOLIST (X L) (F X)))\nTo use the value of an identifier in the function namespace as a\nnormal value,\nLisp\n2\nprovides this notation:\n(FUNCTION <identifier>)\nwhich is often abbreviated as simply\n#'<identifier>\nFor example, in\nLisp\n2\none would write\n(MAPC #'PRINT '(A B C D))\nIn\nLisp\n1\n, one would write\n(MAPC PRINT '(A B C D))\nThe differences are more striking in a larger, more complex\nexample. In\nLisp\n2\n, one can write the\nY\noperator as\n(DEFUN Y (F)\n(   (LAMBDA (G) #'(LAMBDA (H) (FUNCALL (FUNCALL F (FUNCALL G  G)) H)))\n#'(LAMBDA (G) #'(LAMBDA (H) (FUNCALL (FUNCALL F (FUNCALL G  G)) H)))))\nwhile in\nLisp\n1\n, one can write\n(DEFUN Y (F)\n((LAMBDA (G) (LAMBDA (H) ((F (G G)) H)))\n(LAMBDA (G) (LAMBDA (H) ((F (G G)) H)))))\nThe call to this operator in order to compute 6! in\nLisp\n2\nwould look like\n(FUNCALL (Y #'(LAMBDA (FN)\n#'(LAMBDA (X)\n(IF (ZEROP X) 1 (* X (FUNCALL FN (- X 1)))))))\n6)\nIn\nLisp\n1\n, the same call would look like\n((Y (LAMBDA (FN)\n(LAMBDA (X)\n(IF (ZEROP  X) 1 (* X (FN (- X 1)))))))\n6)\nSome argue that the\nLisp\n1\nform is easier to read because it is more\nconcise.  Others feel that the\nLisp\n2\nform is easier to read because\nthe use of functions whose names are not constant is clearly marked.\nProbably a programmer who frequently passes functions as arguments or\nwho uses passed arguments functionally finds\nLisp\n1\nsyntax easier to\nread than\nLisp\n2\nsyntax; the programmer who infrequently passes\nfunctions as arguments and rarely uses passed arguments functionally\nprobably prefers to use a different syntax on those occasions.\n6. Multiple Denotations for a Single Name\nSome find it simple and clear to have a single meaning for a name.\nFewer meanings mean less to remember.  For example, suppose a\nprogrammer has defined the function\nF\nas\n(DEFUN F (X) (+ X 1))\nThen suppose the programmer is writing a new function, G, and wants it\nto take the functional parameter\nF\n, which is to apply to its other\nargument.  Suppose the programmer writes\n(DEFUN G (F) (F 3))\nIssues of defined program semantics aside, it's probably obvious that\nthe programmer meant to call the function named by the formal\nparameter\nF\non the argument 3.\nIn\nLisp\n2\n, however, this function will\nignore its argument named\nF\nand simply invoke the globally defined\nfunction named\nF\non 3.  Notice that this is precisely what Lisp 1.5\nwould have done.\nUnfortunately, not all situations are as clear-cut as this.  For\nexample, consider the following:\n(DEFUN PRINT-SQUARES (LIST)\n(DOLIST (ELEMENT LIST)\n(PRINT (LIST ELEMENT (EXPT ELEMENT 2)))))\nIn this definition, there are three uses of the name\nLIST\n.  The first\nis in the function's formal parameter list.  The second is in\ninitialization of the\nDOLIST\nvariable. The third is in the\nPRINT\nexpression.  This program, which is valid in current Common Lisp,\nwould not be valid in\nLisp\n1\nbecause the name\nLIST\ncould not\nsimultaneously denote a list of numbers and a function.  Such uses are\nfamiliar cause of programmer errors in\nLisp\n1\n.  In\nLisp\n1\n, a common way\nto write this definition would be\n(DEFUN PRINT-SQUARES (LST)\n(DOLIST (ELEMENT LST)\n(PRINT (LIST ELEMENT (EXPT ELEMENT 2)))))\nIn the function\nPRINT-SQUARES\n, the parameter named\nLST\nis better named\nLIST-OF-NUMBERS\n, though some programmers would\nnot use such a long name.\nAs should be clear from these examples, the advantage of treating the\nfunction and argument positions the same is that using parameters as\nfunctions is made more convenient syntactically.\nThe disadvantage is that not using parameters as functions is made\nless convenient syntactically because parameter names must be more\ncarefully chosen so that they do not shadow the names of globally\ndefined functions that will be needed in the function body.\nOf course, care in naming must be observed in\nLisp\n2\nanyway to ensure\nthat variable names chosen for some inner binding do not shadow the\nnames of the variables bound by outer binding constructs.  Consider\nthis example:\n(DEFUN HACK-LIST (LIST)\n(LET ((LST (HACK-LIST LIST)))\n(HACK-SOME-MORE LIST LST)\n(SHUFFLE LIST LST)))\nThere are two variables that could naturally be named '\nLIST\n,' and the\nprogrammer must choose which one to so name.\nNevertheless, the degree of care required to avoid name collisions in\nLisp\n1\nis theoretically no less than that required in\nLisp\n2\nbut\nhas been observed to be far more, a point to which we shall return\nlater.\nThe following is a simple example of some of the important issues in\nvariable naming (using mixed\nLisp\n1\nand\nLisp\n2\nnotation):\n(DEFUN ODDITY (LIST) (LIST LIST LIST))\n(ODDITY #'CONS)\nDepending on which way the issue is decided, the possible return\nvalues from this function might be\n(#<SUBR CONS>  .  #<SUBR CONS>)\n(#<SUBR CONS>  #<SUBR CONS>)\n7. Referential Clarity\nIn\nLisp\n2\n, deciding whether to use the function or the value is\nimpossible unless the context is known.  These two forms result in\ndifferent interpretations of an expression,\nx\n:\n(\nx\n...)\n(...\nx\n...)\nTo some programmers, a basic 'rule' of Lisp style is that code is\nclearest when the least amount of context is necessary to determine\nthe meaning of an expression. Unfortunately, that rule is violated in\nLisp\n2\n.\nIn a presentation at the 1986 ACM Conference on Lisp and Functional\nProgramming, Steele complained that the α operator in Connection\nMachine\nTM\nLisp\n[Steele 1986]\n, which he wanted to implement\nas a simple read macro, could not be\nimplemented that way because of this context problem.  The expansion\nof the α operator depended on whether it was expanding in a\nfunctional or an argument position.  In\nLisp\n1\nthis problem would not\nhave arisen.  In\nLisp\n2\nthe problem could be solved by introducing\n'lambda macros' such as those that are already used in ZetaLisp.\n8. Compiler Simplicity\nCurrent Common Lisp compilers use special case code when deciding\nwhich namespace mapping to use when examining a variable.\nThe maintainers of some Common Lisp compilers claim that a change from\nLisp\n2\nto\nLisp\n1\nsemantics would result in simpler, smaller, faster\ncompilers.  One reason is that knowledge about which namespace is in\neffect at any point is often procedurally embedded.  By merging the\ntwo namespaces, the same pieces of code can be used in more places,\nthus reducing the number of places where such information is\nrepresented and thus making maintenance simpler.\nThe maintainers of other Common Lisp compilers claim, however, that a\nchange from\nLisp\n2\nto\nLisp\n1\nsemantics would reduce the complexity of\ntheir compilers little if at all—that it might force small changes\nat points distributed throughout the system, but that the compiler\nwould not change very much.\nThere is even some concern that the complexity of compilers might\nincrease because of such a change.  This belief is based on the\nobservation that the change would effectively cause type information\nto be lost.  Specifically, for\nLisp\n2\na compiler writer can assume that\nwhatever is in a function cell must be a function; for\nLisp\n1\na\ncompiler writer cannot assume that if a programmer has written an\nexpression that invokes a function associated with a symbol, the\ncontents of the value cell of that symbol will be a function when the\nfunction invocation is performed.\nIn\nLisp\n1\n, this information sometimes may be recoverable, but the\ncompiler may have to perform extensive type inference to do so.\nOften, the compiler will have to take an unnecessarily conservative\napproach.\nConsider a\nLisp\n2\nfunction such as\n(DEFUN F (X) (G X))\nEven in this simple function, we are assuming that\n(SYMBOL-FUNCTION 'G)\nis a function.  When a good compiler is directed to produce safe code,\nthat compiler must concern itself with the question of whether a cell\nwill ever contain a nonfunction.  For some computers, if the compiler\ncannot show that the contents of the function cell is always a\nfunction, it must generate less efficient code.\nCommon Lisp compilers can be written that assume that function cells\nalways contain functions in\nLisp\n2\nbecause it is legal to forbid\nnonfunctions from ever being placed in the function cell.  For\nexample, Vax Lisp\n[Digital 1986]\ndoes this.  Consequently, the Vax\nLisp compiler can safely generate code that simply jumps to the\ncontents of the value cell of G. In\nLisp\n1\n, however, this is not\npossible unless new declarations are introduced.\nThe conclusion here is not that some compilers are better than others,\nbut that compilers may vary widely in their nature, and therefore the\neffects of the proposed change may vary widely depending upon the\nimplementation.\n9. Higher Order Functions\nWhile functions, like\nY\n, that directly manipulate other functions can\nbe written in either\nLisp\n1\nor\nLisp\n2\n, many programmers feel that they\ncan be written more perspicuously in\nLisp\n1\n; therefore, the more\ncumbersome notation of\nLisp\n2\ndoes nothing to encourage and may even\ndiscourage the writing of such functions.\n10. Abstraction Sharing\nIn\nLisp\n1\nit is easier to define a piece of code that shares\nabstractions between data and functions. Again, this is possible in\nLisp\n2\n, but it is not an encouraged style.  The problem is that it is a\nburden to think about which namespace will be used for various\nvariables.\n11. Multiprocessing\nA pure or side-effect-free functional programming style has been seen\nto be successful in multiprocessing; therefore it would seem that a\nLisp-like functional style would be conducive to multiprocessing.\nThat is, a functional style of programming might result in programs\nthat are more easily rendered into a parallel style.  For evidence of\nthis, look at typical Common Lisp programs and contrast their style\nand suitability for parallelization with the same programs as they\nmight be written in Scheme.  By transitivity, since\nLisp\n1\ntends to\nencourage functional programming style, it is also more conducive to\nmultiprocessing.\nOf course, Common Lisp is not designed to accommodate multiprocessing,\nand it would take more than uniting of the function and value\nnamespaces to allow Common Lisp to seriously support multiprocessing.\nIntegrated support of multiprocessing is not currently an explicit\ngoal of Common Lisp.  Nevertheless, it seems apparent that experience\nwith a more functional programming style will provide a good\nfoundation for programmers who later move to a language that does\nsupport multiprocessing.\n12. Number of Namespaces\nThere is really a larger number of namespaces than just the two that\nare discussed here.  As we noted earlier, other namespaces include at\nleast those of blocks and tags; type names and declaration names are\noften considered namespaces.  Thus, the names\nLisp\n1\nand\nLisp\n2\n, which we have been using are misleading.\nThe names\nLisp\n5\nand\nLisp\n6\nmight be\nmore appropriate.\nSince there are other namespaces, the uniting of the function and\nvalue of namespaces does not accomplish as much as might initially\nappear.  Even if they are united, the interpretation of a symbol in a\nCommon Lisp program would still depend on the context to disambiguate\nvariables from symbols, symbols from the type names, and so on.\nOn the other hand, some proponents of uniting have suggested that in\ntime these other namespaces would be collapsed as well.  Dialects of\nScheme have done this—some to a greater extent than others.  The hope\nis that when all namespaces are reduced to a single one, there will be\na single simple evaluation rule for all identifiers.  Because Lisp\ncontains\nQUOTE\n, there is actually an arbitrary number of namespaces\nbecause of the existence of functions like\nGET\n, and\nGETHASH\nthat allow\nusers to effectively associate new kinds information with symbols.\nEven if the underlying Lisp supports exactly one namespace,\nprogrammers will be able to invent other namespaces.  Reducing the\nnumber of namespaces in the Lisp to one will help programmers keep\ntrack of their own namespaces, but the \"one identifier, one meaning\"\nmotto will not necessarily apply to user code.\nSuppose a programmer has defined a macro like this:\n(DEFMACRO ADD-AUTOMOBILE (AUTO SPECS-FN DATABASE)\n`(LET ((THE-CAR (GETHASH (QUOTE ,AUTO) *AUTO-HASH-TABLE*)))\n(ADD-AUTOMOBILE-INTERNAL\nTHE-CAR (FUNCALL ,SPECS-FN THE-CAR) ,DATABASE)))\nThen interpreting the identifier\nCAR-HPM\nin the next form is not very\ndifferent from interpreting other identifiers using the built-in\nnamespaces:\n(ADD-AUTOMOBILE CAR-HPM CURRENT-YEAR-SPECS CAR-DATABASE)\nAn argument has been presented that may have left the impression that\nbecause a\nLisp\n1\ncompiler can be simpler than a\nLisp\n2\ncompiler there is an implied simplicity of\nLisp\n1\nover\nLisp\n2\n.  But the\nquestion of whether a compiler for\nLisp\n1\nis more or\nless complicated than a compiler for\nLisp\n2\nis a\nstatement about the abstract effect of the different namespace\ncomplexities.  The additional meanings that can be associated with\nsymbols can and do have a very powerful effect.\nIndeed, much of the power of associative functions like\nGET\nderives\nfrom a structured pun—the fact that a single symbol may have more\nthan one kind of information associated with it.  The power and\nimportance of this kind of structured interplay between arbitrary\nnamespaces is hard to deny.\n13. Macros and Name Collisions.\nSome contend that macros as they exist in Common Lisp have severe\nsemantic difficulties.  Macros expand into an expression that is\ncomposed of symbols that have no attached semantics.  When substituted\nback into the program, a macro expansion could conceivably take on\nquite surprising meaning depending on the local environment.\nSome symbols that ultimately appear in the expansion of a macro are\nobtained during macro definition through its parameter list from the\nmacro consumer.  It is possible to use those symbols safely.  However,\nwriters of macros often work on the hypothesis that additional\nfunctional variables may be referenced in macros as if they were\nglobally constant.  Consider the following macro definition for\nLisp\n1\nor\nLisp\n2\n:\n(DEFMACRO MAKE-FOO (THINGS) `(LIST 'FOO ,THINGS))\nHere\nFOO\nis quoted,\nTHINGS\nis taken from the parameter list for the\nMacro, but\nLIST\nis free.  The writer of this macro definition is\nalmost certainly assuming either that\nLIST\nis locally bound in the\ncalling environment and is trying to refer to that locally bound name\nor that list is to be treated as constant and that the author of the\ncode will not locally bind\nLIST\n. In practice, the latter assumption is\nalmost always made.\nIf the consumer of the above macro definition writes\n(DEFUN FOO (LIST) (MAKE-FOO  (CAR  LIST)))\nin\nLisp\n1\n, there will probably be a bug in the code.\nHere is another example of code that would be a problem in\nLisp\n1\n:\n(DEFMACRO FIRST (LIST) `(CAR ,LIST))\n(DEFMACRO REST (LIST) `(CDR  ,LIST))\n(DEFUN TEST-CAR  (CAR TEST-LIST)\n\"The 'driver' program for Frobozz Automobile, Inc.'s\nquality assurance test.\"\n(DO ((TESTS TEST-LIST (REST TESTS)))\n((NULL TESTS))\n((FIRST TESTS) CAR)))\nIt's worth emphasizing, however, that these problems occur in either\nLisp\n1\nor\nLisp\n2\n.  The issue is that they are more likely to occur in\nLisp\n1\nbecause there is less contextual information available.  Here is\nan example of how the problem arises in normal Common Lisp:\n(DEFMACRO FOO (X Y) `(CONS 'FOO (CONS ,X (CONS ,Y NIL))))\n(DEFUN BAZ (X Y)\n(FLET ((CONS (X Y) (CONS Y X)))\n(FOO X Y)))\n(BAZ 1 2)\nreturns\n(((NIL . 2) . 1) . FOO)\neven though it seems that\n(FOO 1  2)\nmight have been intended by the programmer.\nAlthough few implementations support its full generality in file\ncompilation, a strict reading of the Common Lisp specification seems\nto imply that writing the following should be acceptable:\n(DEFMACRO FOO (X Y) ;take deep breath\n`(FUNCALL ',#'CONS 'FOO (FUNCALL ',#'CONS ,X (FUNCALL ',#'CONS ,Y NIL))))\n(DEFUN BAZ (X Y)\n(FLET ((CONS (X Y) (CONS Y X)))\n(FOO X Y)))\nHere\n(BAZ 1 2)\nshould evaluate to\n(FOO 1 2)\njust as\neveryone expected.  Of course,\nFUNCALL\nis subject to the same problems\nas\nCONS\nwas; either\nFUNCALL\nmust be considered a constant function or\na construct such as\n('#<COMPILED-CODE CONS>  ...)\nShould be specially understood by the compiler and interpreter.\nGiven all of this, the thoughtful reader might ask: Why do macros\nappear to work as often as they do?\nThe answer seems to be based in history and statistics rather than in\nsome theoretical foundation.  In dialects preceding Common Lisp, such\nas MacLisp, it was fortunate that\nFLET\n,\nLABELS\n,\nMACROLET\ndid not\nexist.  Thus in these dialects there was an extremely high likelihood\nthat the function bindings of identifiers in the macro expander's\nenvironment would be compatible with the function bindings of the same\nidentifiers in the program environment.  This coupled with the fact\nthat the only free references that most macro expansions tend to make\nare functional meant that writers of macros could guess enough\ninformation about how the expansion would be understood and could\ndevelop fairly reliable macro packages.\nWith the advent of\nFLET\n,\nLABELS\n, and\nMACROLET\n, the risk of conflict is\nconsiderably higher.  The Scheme community, which has long had\nconstructs with power equivalent to that of these forms, has not\nadopted a macro facility.  This is partly because macros have\ngenerally seemed like a semantically empty concept to many of the\nScheme designers.\nCommon Lisp programmers probably have little trouble because they are\nstill programming in a MacLisp programming style, using forms like\nFLET\nand\nLABELS\nin limited ways.  People who use\nFLET\nand\nLABELS\nheavily may well have learned Lisp with Scheme and do not use macros\nheavily, or they understand the issues outlined here and write macros\ncarefully.\nAs time goes on, it should not be surprising to find users of Common\nLisp macros reporting more name collision problems.  A change from\nLisp\n2\nto\nLisp\n1\nsemantics for identifiers would probably speed up the\nincrease in these problems.\n14. The Benefits of Macros\nAlthough macros have semantic difficulties, they are pragmatically\nuseful, as are other constructs that don't add semantic power to a\nlanguage.  For example, in a Lisp with\nIF\nand\nPROGN\n,\nthe additional semantic power of\nCOND\nis null.\nYet\nCOND\nbuys stylistic improvements\nto some Lisp code, especially to code written\nwith\nIF\nand\nPROGN\nthat\nwould be indented too far to the right in proper indentation style or\ncode that would not highlight the relationships of the conditions\nbeing tested because they would not be placed, vertically, near each\nother.\nTherefore, semantically poor constructs like macros can help\nprogrammers organize their code to be more readable and maintainable,\nand so that it expresses the abstractions in such a way that the code\nruns efficiently.\nCommon Lisp programmers are judged on their ability to use macros\nappropriately and judiciously.  Without the pervasive use of macros, a\nmodern Lisp programming style would not have been developed, and Lisp\nas a mature programming language would have never come about.  Many\nbelieve that the powerful Lisp macro facility is the main reason that\nLisp has been successful over the years.\nMacros have formed the basis for efficient abstraction within Lisp.\nThey can be used to optimize the generated code by examining the forms\npassed to the macro definition function, and different code can be\nproduced depending on the shape of those forms.  Macros can be used to\ndefine extensions to Lisp because macros enable the programmer to\ndefine new evaluation rules.\nMost programmers simply do not experience the name collision problems\nmentioned in the previous section with the frequency that seems to be\nappropriate to the depth of the problem, largely because of the\nexistence of a function namespace.\nFLET\nand\nLABELS\ndefine functions,\nand programmers treat function names more carefully than nonfunction\nnames.  Therefore, letting function names be freely referenced in a\nmacro definition is not a big problem.\nThere are two ways to look at the arguments regarding macros and\nnamespaces.  The first is that a single namespace is of fundamental\nimportance, and therefore macros are problematic.  The second is that\nmacros are fundamental, and therefore a single namespace is\nproblematic.\n15. Space Efficiency\nIf a symbol is used both for its value and as a function, it currently\ncosts no additional space.  Any program that has symbols that are used\nto denote distinct functions and values, however, would have to be\nchanged.  In general, this means that some new symbols would be\nintroduced.  In most cases, the number of new symbols introduced would\nprobably be small, but there might be pathological applications that\nwould be exceptions.\nIn the Lucid Lisp system\n[Lucid 1986]\n, there are 14 of these symbols,\nand in these cases the value cell is being used as a cache for an\nobject related to the function.  In the MACSYMA system\n[Symbolics 1986a]\nthere are roughly 35 of these symbols out of\na total of 10,000.\nUsing the same name to refer to both a function and a value cell can\nbe more space efficient, since it means only one additional cell to an\nexisting data structure that already has on the order of 5 to 10\ncells.\nThis issue can be illustrated quantitatively.\nLet\nn\nbe the number of symbols in a system,\nlet\nS\n1\nbe the space occupied by the average\nsymbol in an implementation of\nLisp\n1\n,\nlet\nS\n2\nbe the space occupied by\nthe average symbol in an implementation of\nLisp\n2\n,\nand\nlet\nx\nbe the number of symbols that must be added to a\nsystem to resolve name conflicts.\nThen the space saved by having separate environments is\n(n + x) S\n1\n- nS\n2\nFor example, if\nn\nis 8000,\nx\nis 14,\nS\n1\nis 28 (bytes), and\nS\n2\nis 32 (bytes),\nthen the space saved by\nLisp\n2\nis -31608 (bytes).  That is,\n12% of the symbol space used by such a\nLisp\n2\nimplementation might be\nsaved if it were made to be a\nLisp\n1\nimplementation.  For there are to\nbe no net change in the amount of storage between two-namespace and a\none-namespace Lisp, more than 1100 symbols would need to be added to\nthe system to resolve name conflicts.\nThe issue is not likely to be important.\n16. Time Efficiency\nIn\nLisp\n2\n, a function call to a function associated with a symbol\ninvolves the use of indirection through the symbol's function cell,\nwhich points to a piece of code possibly with an intermediate pointer\nthrough a procedure object, as in S-1 Lisp.\nAn optimization to this is to eliminate the indirection through the\nsymbol's function cell and have a function call jump directly to the\ncorrect code object, perhaps indirecting through a link table in order\nfor\nDEFUN\nand\nSETF\nof\nSYMBOL-FUNCTION\nto cause existing running code\nto call a redefined function, the operation of changing a symbol's\nfunction cell must invalidate the link table or otherwise cause the\ncorrect new link to be made.\nIn\nLisp\n1\n, the straightforward implementation of function calling would\ncheck the value cell for a valid function on each function call.\nTo use the link table optimization in\nLisp\n1\n,\nSETQ\nrather than\nSETF\nof\nSYMBOL-FUNCTION\nmust do the invalidating or relinking.  Of course,\nonly an assignment to a symbol needs to be checked. In the worst case\nSETQ\nwould become a function call rather than being open-code; in this\nsituation, the speed loss could be the difference between a single\ninstruction and about 30 instructions.\nIn the expected case a single\nSETQ\nwould become two\nSETQ\ns.  The\nimplementation for this case is for each symbol to have a hidden\nfunction cell that always contains a valid function, perhaps a trap\nfunction.  Function calls go through the hidden function cell as\nusual, but\nDEFUN\nand\nSETQ\nalways manipulate both the value cell and\nthe hidden function cell.  Every\nSETQ\nalso assigns a trap function to\nthe hidden function cell, so that the next function call through that\nsymbol runs trap code that establishes the valid link to the real code\nor signals an error.\nOn some stock hardware, tricks with the addressing hardware and word\nalignment can be played to get away with having only a value cell and\nnot having\nSETQ\ntake any more time than it would in\nLisp\n2\n.\nEven with the two-\nSETQ\nimplementation the additional overhead for the\nSETQ\nof\nsymbols should not cause more than 10% degradation in the most\npessimistic inner loop, and overall it is unlikely to cause a\nnoticeable degradation in a large system.\nThe number and complexity of space and time trade-offs discussed here\nmight be confusing.  First, the reason that a sophisticated\nfunction-calling method is chosen by Lisp implementors for stock\nhardware implementations is that a shorter and faster function-calling\nsequence can be gained using various tricks, some of which require\ntables of information needed when functions are redefined; usually the\nobjects representing compiled functions in these implementations can\nbe shortened as well.  The space gained by these shortenings is\nbalanced fairly well with the storage needed for the tables.  Second,\nchanging from\nLisp\n2\nto\nLisp\n1\nresults in a smaller Lisp image because\nof the reduction in storage needed for symbols.  Third, the additional\ncode needed for testing assignment of symbols decreases the speed of\nrunning code and increases its size.  If a function cell is supported\nas a means of providing fast function calling, then there is no space\ngained by eliminating the function cell—each symbol still has one.\nBecause assignment to symbols is infrequent and because changing\nfunction definitions associated with symbols is rare, the speed\ntrade-off probably results in a negligible loss in speed, and the\nspace trade off probably results in a small space increase.\nThis issue is an illustration of the earlier claim that simplifying\nthe surface language might not always result in a simpler\nimplementation strategy: This is one of several ways that the\nimplementation might become more complicated as a result of such a\nchange.\n17. Global Variables, Special Variables, and Constants.\nA free variable in Common Lisp is currently taken to be a dynamic\nrather than a lexical reference because there is no global lexical\nenvironment in Common Lisp. In this code\n(DEFUN PLUS (X Y) (+ X Y))\n(DEFUN SOMEWHAT-MORE-THAN (X) (PLUS X *SOMEWHAT*))\nThe reference to\n*SOMEWHAT*\nis special (dynamic).\nOn the surface, in\nLisp\n1\nthe reference to\nPLUS\nis free also, and thus it is special (dynamic).\nWhen a variable is declared special, a free reference to it is to the\nmost recent dynamically bound value for it; all bindings of it become\nspecial (dynamic) bindings.  When a variable is declared constant,\nfree references to it are to its permanent constant value, and\ncompilers are free to fold that constant into the code they emit.\nWe introduce the concept of global variables; when a variable is\nglobal, free references to it are to the value cell of the symbol\nnamed by the variable, and all bindings of it are still lexical.\nTo avoid a compiler warning for free use of a variable like\n*SOMEWHAT*\n, the variable is declared\nSPECIAL\n.  In order to have\ncompilers for\nLisp\n1\nnot to warn about the free use of\nPLUS\n, it would\nbe unfortunate to have to declare it\nSPECIAL\n.\nAs noted, in Common Lisp the default for free variable references is\nSPECIAL\n; that is, a free variable reference is taken to be a special\nvariable reference.  If the default in\nLisp\n1\nwere that free variable\nreferences were global (lexical), then it would make sense for a\ncompiler not to warn about such free variable references.\n17.1 An Approach to Free Functional Variables\nOne approach to this problem would be to introduce a new declaration\nthat made a variable (lexically)\nGLOBAL\nbut not\nSPECIAL\n.\nDEFUN\ncould\nimplicitly declare function names\nGLOBAL\n. With such a declaration, in\na deep-bound\nLisp\n1\n, the compiler would not need to emit code to search\nthe dynamic binding chain to determine what code to invoke for\nPLUS\nin\nSOMEWHAT-MORE-THAN\n.\nGiven such a declaration, it would still be possible in\nLisp\n1\nto write\ndefinitions such as the following:\n(DEFUN ZAP (FN X Y)\n(LET ((PLUS (LAMBDA (X Y) (MAPCAR PLUS X Y))))\n(LIST (PLUS (FN X) (FN Y)) (PLUS (FN (FN X)) (FN (FN Y))))))\nwhere\nPLUS\nis defined above, without worrying that the\nLET\n-binding of\nPLUS\nwould affect the argument\nFN\n.  To explain the issues better, here\nthe references to\nPLUS\nare numbered and the definition is shown in a\ndifferent typeface:\n(DEFUN ZAP (FN X Y)\n(LET ((\nPLUS\n1\n(LAMBDA (X Y) (MAPCAR\nPLUS\n2\nX Y))))\n(LIST (\nPLUS\n3\n(FN X) (FN Y)) (\nPLUS\n4\n(FN (FN X)) (FN (FN Y))))))\nPLUS\n1\nis a lexical binding of the variable named\nPLUS\n;\nPLUS\n2\nreferences the global value of the symbol\nnamed\nPLUS\n;\nPLUS\n3\nand\nPLUS\n4\nare lexical references to the binding of\nPLUS\n1\n.\nIf\nFN\nis bound to a function that is defined likes this, for instance,\n(DEFUN BAZ (X) (LIST X (\nPLUS\n5\nX X)))\nthen\nPLUS\n5\nrefers to the global value\nof\nPLUS\nrather than to the\nLET\n-bound value in\nFOO\n.\nIf\nDEFUN\nwere to declare function names\nSPECIAL\n,\nthen\nPLUS\n2\nand\nPLUS\n5\nwould refer to the\nSPECIAL\nbinding for\nPLUS\n, namely\nPLUS\n1\n, in this example.\n17.2 A Second Approach to Free Functional Variables\nAn alternative approach is for\nDEFUN\nto implicitly declare function\nnames constant.  Redefining a function might cause some compilers to\nwarn that some constant function definitions had been folded into\ncode.\nA mixed approach would be for all built-in Common Lisp functions to be\ndeclared constant, while\nDEFUN\nwould implicitly declare function names\nglobal.\nClosely related to this issue is the fact that there is currently no\nsystem-provided dynamic variation of\nFLET\nand\nLABELS\nin Common Lisp,\nalthough in a nonmultiprocessing environment they can be simulated by\ncreative use of\nUNWIND-PROTECT\n.  If Common Lisp were made a\nLisp\n1\ndialect, dynamic functional variables would be something the language\nwould get 'for free.'  And if their use became popular, it might be\ndesirable to have two kinds of\nDEFUN\n—one that created special\ndefinitions and another that created lexical definitions.\n18. Compatibility Issues.\nA transition from\nLisp\n2\nsemantics to\nLisp\n1\nsemantics would introduce a\nconsiderable amount of incompatibility. There is the question of\nimplementor problems as well as user problems.\n18.1 Change Existing Code\nLarge bodies of code already exist that assume the current semantics.\nThat code would have to be changed.  Users who did not favor this\nchange would probably resent the amount of work required to make the\nchange, which might be nontrivial.\nIn some cases, mechanical techniques could be used to diagnose which\nprograms need to be changed.  However, because of the pervasive use of\nmacros and of automatic programming techniques, it would not be\npossible to do such diagnosis with 100% reliability.\nAs a sort of machine-gun approach to the problem, compilers could be\nmodified to provide the user with information about conflicts as they\noccur.  This would address some problems in automatic programming that\ncould not be detected by statically examining the code that does such\nprogramming.\nHowever, some situations are still more complicated because they do\nnot directly produce code; instead, they examine and modify code.  For\nexample, compilers, translators, macros, and code walking utilities\nmay have built-in assumption about the number of namespaces; if these\nassumptions are never explicitly represented, they might elude\nautomatic techniques, which could lead to errors or inefficiencies\nlater on.\n18.2 Compatibility Packages\nVarious compatibility schemes have been proposed that allow these\nproblems to be moderated.  For example, we might have a Common Lisp\nwith\nLisp\n1\nsemantics that has a compiler switch that allows\nLisp\n2\ncode\nto be compiled and run.  Symbols would have function cells, but\nfunction cells that were possibly represented as properties on\nproperty lists.  All old Common Lisp code on the form:\n(F ...)\nWould be transformed to this:\n(FUNCALL #'F ...)\nWhere\nFUNCTION\nwould look things up in the 'function cell.'\nFUNCALL\nwould be retained in the compatibility package.  A bigger example is\nmore convincing:\n(LET ((LIST ...))\n(LIST ...))\nwould become\n(LET ((LIST ...))\n(FUNCALL #'LIST ...))\nDuring the transformation process, variables bound by occurrences of\nFLET\nand\nLABELS\nin the old code would be renamed to\nnew names produced by\nGENSYM\n, and the\nLisp\n1\nversions of\nFLET\n(which is\nLET\n) and\nLABELS\nwould be substituted for the function namespace versions.\nSome compilers may already perform this transformation internally and\nwill be simplified after the change.  And perhaps an implementor will\nwant to provide a real function cell for this compatibility in order\nto run old code relatively fast.  Lisps that normally have link tables\nwill need to provide separate linking code (possibly the old link\ncode) for the compatibility package.\nThis type of compatibility takes a\nLisp\n2\nprogram and\nproduces a\nLisp\n1\nprogram that uses some\ncompatibility features for\nLisp\n2\nprograms added to\nthe\nLisp\n1\n.  In theory, the\nLisp\n2\nsource for the transformed program could be thrown away, and then only\nthe\nLisp\n1\ncode with the compatibility features could\nbe used for the feature.\nUnfortunately, there are several problems with this simple kind of\ncompatibility.\nFirst, it does not easily lend itself to mixing compiled and\ninterpreted code, especially when such code is produced at runtime.\nIt becomes important, for example, to clearly document and control\nwhether functions that receive expressions to be evaluated or code-\nwalked are receiving expressions in\nLisp\n1\nor\nLisp\n2\n.\nAlso, the compatibility package might expand expressions into code\nthat was opaque to code walkers, compilers, and macro facilities,\nwhich might have built-in assumptions about the expected kinds of\nexpressions.  For example, the proposed compatibility translation may\ninvolve treating some forms that were documented as special forms as\nif they were macros.  Possibly a code-walker expecting to see a\ncertain class of expressions would see a different class of\nexpressions after compatibility translation.\nAnother problem occurs when both the compatibility code and the\nLisp\n2\ncode to be translated use property lists to hold the 'function cells.'\nIn this case the running\nLisp\n1\nversion of the\nLisp\n2\ncode might destroy\npart of the compatibility information.\nThere is a class of\nLisp\n2\nprograms that could be safely run under this\ntranslation style of compatibility.  There is also, clearly, a class\nof programs that require a stricter compatibility.\nA second stage of compatibility would require, essentially, a complete\nimplementation of the semantics of\nLisp\n2\nexisting alongside of and\nsharing code with the\nLisp\n1\n.  For example, a 'real' function cell\nwould need to be implemented along with an EVAL and a compiler—the\ncompiler would be a combination of the translator mentioned above and\nthe\nLisp\n1\ncompiler.\nSome programs may function correctly but suffer an efficiency loss\nthat is greater than the simple loss that might be assumed by just\nanalyzing the theoretical speed of the compatibility code.  For\nexample, the compiler might be able to perform better optimizations on\nthe original program than on the same program under the compatibility\npackage.\nAs mentioned, a simple compatibility package can probably take care of\na certain class of Common Lisp programs, but for programs that would\nrequire an implementation of\nLisp\n2\nin\nLisp\n1\nfor compatibility, it is\nprobably best to require programmers to translate those programs to\nLisp\n1\n.\n19. Standardization\nIn standardizing a language, we should take care to standardize those\nthings that have had proven success and acceptance by a user\ncommunity.  It is often dangerous to standardize on the most recently\nformulated ideas.  The new macro solution by Kohlbecker\n[Kohlbecker 1986]\nis of this form.\n20. Summary\nThe bulk of arguments that focus on clean semantics and notational\nsimplicity tend to favor uniting the function and value namespaces.\nIn spite of this, there are those who hold strongly to a belief that a\ntwo-namespace system affords useful expressive power that they are\nunwilling to do without.  In the end, practical considerations favor\nthe status quo for Common Lisp.  There is a large number of\nimprovements beyond a single namespace that could be made to Common\nLisp that would clean it up and simplify it.  We feel that the time\nfor such radical changes to Common Lisp passed, and it would be the\njob of future Lisp designers to take lessons from Common Lisp and\nScheme to produce an improved Lisp.\n21. Acknowledgements\nThe authors also gratefully acknowledge the useful commentary and\nsupport of Will Clinger, Scott Fahlman, David Moon, and JonL White.\nReferences\n[Abelson 1985]\nH. Abelson and G.J. Sussman with J. Sussman,\nStructure and Interpretation of Computer Programs\n,\nThe MIT Press, Cambridge, Massachusetts, 1985\n[Brooks 1982]\nR. A. Brooks, R.P. Gabriel, and G.L. Steele Jr.,\nS-1 Common Lisp Implementation\n,\nProceedings of the 1982 ACM Symposium on Lisp and Functional Programming,\nPittsburgh, PA, August 1982.\n[Digital 1986]\nDigital Equipment Corporation,\nVAX LISP/VMS User's Guide\n,\nMaynard, MA, 1986.\n[Gabriel 1985]\nR.P. Gabriel,\nPerformance and Evaluation of Lisp Systems\n,\nThe MIT Press, Cambridge, MA 1985.\n[Halstead 1984]\nHalstead, Robert,\nMultiLisp\n,\nProceedings of the 1984 ACM Symposium on Lisp and Functional Programming,\nAugust 1984.\n[Kohlbecker 1986]\nE.E. Kohlbecker, Jr.,\nSyntactic Extensions in the Programming Language Lisp\n,\nPhD thesis, Indiana University, August 1986.\n[Lucid 1986]\nLucid, Inc.,\nLucid Common Lisp Reference Manual for the VAX\n,\nMenlo Park, CA, 1986.\n[McCarthy 1965]\nJ. McCarthy, et al,\nLisp 1.5 Programmer's Manual\n,\nThe MIT Press, Cambridge, Massachusetts, 1965.\n[Padget 1986]\nJ. Padget, et al,\nDesiderata for the standardisation of LISP\n,\nProceedings of the 1986 ACM Conference on Lisp and Functional Programming,\nCambridge, MA, August 1986.\n[Pitman 1983]\nK.M. Pitman,\nThe Revised Maclisp Manual\n(Saturday Evening Edition),\nLCS Technical Report 295, MIT, May 1983.\n[Rees 1986]\nJ. Rees and W. Clinger, editors,\nRevised\n3\nReport on the Algorithmic Language Scheme\n,\nSIGPLAN Notices 21(12), September 1986.\n[Steele 1984]\nG.L. Steele Jr.,\nCommon Lisp, The Language\n,\nDigital Press, Billerica, Massachusetts, 1984.\n[Steele 1986]\nG.L. Steele Jr. and W.D. Hillis,\nConnection Machine\nTM\nLisp:\nFine-Grained Parallel Symbolic Processing\n,\nProceedings of the 1986 ACM Conference on Lisp and Functional Programming,\nCambridge, MA August 1986.\n[Sussman 1975]\nG.J. Sussman and G.L. Steele Jr.,\nSCHEME: An Interpreter for Extended Lambda Calculus\n,\nAI Memo 349,\nMIT, Cambridge MA, December 1975.\n[Symbolics 1986a]\nSymbolics, Inc.,\nMACSYMA Reference Manual\n,\nCambridge, MA, 1986.\n[Symbolics 1986b]\nSymbolics, Inc.,\nSymbolics Common Lisp: Language Concepts\n,\nEncyclopedia Symbolica, Volume 2A, 296-297,\nCambridge, MA 1986.\nOriginal printed text document\nCopyright 1988 by Richard P. Gabriel and Kent M. Pitman.\nAll Rights Reserved.\nHTML hypertext version of document\nCopyright 2001 by Kent M. Pitman and Richard P. Gabriel.\nAll rights reserved.\nThe following limited, non-exclusive,\nrevokable licenses are granted:\nBrowsing of this document (that is, transmission and display of a temporary\ncopy of this document for the ordinary purpose of direct viewing by a\nhuman being in the usual manner that hypertext browsers permit such\nviewing) is expressly permitted, provided that no recopying,\nredistribution, redisplay, or retransmission is made of any such copy.\nBookmarking of this document (that is, recording only the document's title and\nUniform Resource Locator, or URL, but not its content,\nfor the purpose of remembering an association between the document's title\nand the URL, and/or for the purpose of making a subsequent request\nfor a fresh copy of the content named by that URL)\nis also expressly permitted.\nAll other uses require negotiated permission.\nClick here for an index\nof other titles by Kent Pitman.",
    "description": "",
    "id": null,
    "short_id": null,
    "url": "https://www.nhplace.com/kent/Papers/Technical-Issues.html",
    "score": "5",
    "tags": "historical",
    "domain": "nhplace.com",
    "author": "veqq",
    "author_url": "veqq",
    "time": "4 hours ago",
    "comments_text": "no comments",
    "comments_url": "no comments",
    "description_hint": null
  },
  "cached_at": "2026-02-12T05:05:35.858452"
}