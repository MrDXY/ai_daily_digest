{
  "url": "https://alexkondov.com/use-databases-without-putting-domain-logic-in-them/",
  "payload": {
    "title": "Using Databases Without Putting Domain Logic in Them (2023)",
    "content": "Even though I’m very passionate about front-end development now, I started my career with different intentions. For the first few years, I worked predominantly on the back-end, and to this day, I move to the full-stack gray area when the situation demands it.\nBut databases are one part of the stack that’s always given me trouble.\nCode is ephemeral by nature. Every deployment can completely change its design or structure with little regard to its previous state. As long as it produces the desired output and side effects, you can refactor the implementation to support new requirements.\nData is not like this.\nData can’t be (easily) changed to fit new business needs. You can’t delete it and start from scratch because your users depend on it. And if a bug corrupts it, it’s not just a matter of resolving the cause. You have to put the data in order too.\nI don’t have any claims of mastery over databases. I have a passable knowledge of SQL and a limited understanding of data modeling in NoSQL databases.\nStill, to make my life easier, I’ve reached an important conclusion - utilize databases as much as possible without putting domain logic in them.\nLogic in the Database\nMost applications will want to execute logic as a result of something happening with their data. You can update a table holding statistics as a new record is saved or modify related records in a denormalized store when one is updated.\nIt’s very appealing to implement this functionality in the database using some sort of trigger or stored procedure. After all, the store is doing all the work, and we would save an additional call from the application.\nBut this approach introduces maintainability problems and breaks the separation of concerns we hold so dear.\nWe’re used to the application being the engine behind a product. It handles input from users, delivers output, and creates all the necessary side effects like database calls. If I have to work on a Node-based REST API, I would look through its handlers and files to see how it works\nSo it can be confusing if some of this functionality is implemented in the database instead.\nMaintaining software is hard enough, so if we split our domain logic between the application and its storage, we’re not doing ourselves a favor.\nThe functionality implemented outside our codebase is not subject to the same design rules and patterns we follow. Also, engineers proficient in the programming language we chose may lack the knowledge and understanding of the databases’ mechanisms.\nIn effect, this is like introducing another language to your tech stack.\nThis leaves more room for error and makes our logic harder to test since it can’t be easily mocked or executed with the rest of our application-level tests.\nUtilize Without Adding Domain Logic\nWith all that said, we do want to take advantage of all our database’s capabilities. If there’s a way to do more with a single query, without writing logic in the store, then we should do so.\nI recently worked on functionality that allowed users to like and unlike posts. However, I wasn’t supposed to remove the entry in the database when they unliked something because, who knows, an analyst might find a correlation that leads to better profits based on that.\nI needed a simple flag that specified the status of the entry, and there’s a straightforward way to implement the liking functionality with it.\nasync\nfunction\nlikePost\n(\nuserId\n,\npostId\n) {\n// Check if the user has already interacted this post.\nconst\nlike\n=\nawait\nrepository.\ngetLike\n(userId, postId)\nif\n(like.status\n===\nStatus.Liked) {\n// Do nothing\nreturn\n}\nif\n(like.status\n===\nStatus.Unliked) {\n// An entry exists but was unliked, so update its status\nreturn\nrepository.\nupdateLike\n(userId, postId,\n'liked'\n)\n}\n// Create a new entry\nreturn\nrepository.\ncreateLike\n(userId, postId)\n}\nThis leads to a more imperative implementation in which we have to make two queries in most cases and implement more functionality ourselves. It’s closer to our natural way of thinking - if I were to describe the solution to this problem verbally, this is what I would probably say.\nBut an alternative would be to make our database do more work for us and add a unique index based on the\nuserId\nand\npostId\n.\nIf we have a unique index on the post and user IDs we can always try to create a new entity without a check before that. If an entity already exists, we can write an\nON CONFLICT\nclause in the query and update it. This way, we utilize our database and remove complexity from our application at the same time.\nasync\nfunction\nlikePost\n(\nuserId\n,\npostId\n) {\n// Create an entry or mark it as liked if it already exists\nreturn\nrepository.\nmarkAsLiked\n(userId, postId)\n}\n// And we need to add this to our SQL query once we have the unique index\n;\n`\n...\nON CONFLICT (user_id, post_id)\nDO UPDATE saved = TRUE,\n...\n`\nYou could argue that having two separate handlers and methods would be a better design choice, but I’m just trying to illustrate the point.\nWe can also look for ways to improve how we fetch data. I write code the way I think about the logic in my head. But instead of firing multiple queries, we explore nested queries to reduce the calls to the database.\nAnd it’s not only SQL databases that we should aim to take full advantage of. DynamoDB, for example, has a\nFilterExpression\nparameter that allows you to filter results based on criteria that are not present in its primary index.\nexport\nconst\nfindAll\n=\nasync\n()\n=>\n{\nconst\nresult\n=\nawait\nDynamoDB.\nquery\n({\nTableName:\n'items'\n,\nFilterExpression:\n'#status = :status and #deadline > :deadline'\n,\nExpressionAttributeNames: {\n'#status'\n:\n'status'\n,\n'#deadline'\n:\n'deadline'\n,\n},\nExpressionAttributeValues: {\n':status'\n:\n'active'\n,\n':deadline'\n:\nnew\nDate\n().\ngetTime\n(),\n},\n}).\npromise\n()\nreturn\nresult.Items\n}\nWhile this gives you more flexibility, the tricky detail is that filtering happens only after your data is fetched. This is not different from fetching the results and filtering them inside your application. It just saves you some keystrokes.\nexport\nconst\nfindAll\n=\nasync\n()\n=>\n{\nconst\nresult\n=\nawait\nDynamoDB.\nquery\n({\nTableName:\n'items'\n,\nIndexName:\n'status-deadline-index'\n,\nKeyConditions: {\nstatus: {\nComparisonOperator:\n'EQ'\n,\nAttributeValueList: [\n'active'\n],\n},\ndeadline: {\nComparisonOperator:\n'GT'\n,\nAttributeValueList: [\nnew\nDate\n().\ngetTime\n()],\n},\n},\n}).\npromise\n()\nreturn\nresult.Items\n}\nInstead, we should focus on the table’s design and leverage our indexes better for our access patterns. We can create secondary indexes that allow us to retrieve data based on different columns.\nThe Line Between Domain and Utility\nIt’s not always clear where the line stands. In the\nON CONFLICT\nexample above, you could make a point that leaving this logic in the database is breaking the very rule we’ve been discussing so far. But to me, it all comes down to whether the database is making decisions of when and how something should be stored.\nIt should only act as a holder of information.\nSo in the example with\nON CONFLICT\n, the database gives us a mechanism to describe what happens if a record that matches a certain constraint exists. We’re not letting any code live in it, and we’re taking full advantage of its capabilities.\nReacting to Events\nOur main reason to rely on the database to work for us remains - responding to something happening to the data. To retain the maintainability of our product, I would implement it entirely in the application, not relying on database triggers.\nTriggers can hide important information about how our domain operates.\nEventually-consistent stores like DynamoDB remain a problem, though. We can’t rely on a successful response from them to run functionality that expects the data to be stored because it still may not be present in all partitions.\nIn most cases, the data will be replicated very fast, but it remains an actual race condition.\nIn cases like this, we should try to reduce the exposure of business logic to the store. In the case of Dynamo, we’ll have to use a trigger to make sure that the change has been propagated, but we can implement the functionality inside a lambda function.\nThe Bottom Line\nI’m sure there are valid cases where moving functionality inside the database is the only reasonable way to solve a business problem. But in nine out of ten cases, you’d be better off not doing it.\nUtilize the full extent of your database’s capabilities, but don’t put domain logic in it.",
    "description": "",
    "id": null,
    "short_id": null,
    "url": "https://alexkondov.com/use-databases-without-putting-domain-logic-in-them/",
    "score": "3",
    "tags": "databases",
    "domain": "alexkondov.com",
    "author": "rebeca",
    "author_url": "rebeca",
    "time": "9 hours ago",
    "comments_text": "3 comments",
    "comments_url": "3 comments",
    "description_hint": null
  },
  "cached_at": "2026-02-12T05:05:35.907628"
}