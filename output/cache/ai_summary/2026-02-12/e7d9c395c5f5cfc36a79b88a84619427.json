{
  "url": "https://matklad.github.io/2026/02/11/programming-aphorisms.html",
  "summary": {
    "summary": "æ–‡ç« ä»¥ Zig å³å°†ç§»é™¤â€œç¯å¢ƒ IO å…¨å±€å¯è¾¾â€èƒ½åŠ›ä¸ºèƒŒæ™¯ï¼Œé€šè¿‡ä¸€ä¸ª readHistory çš„ API è®¾è®¡è®¨è®ºï¼Œå±•ç¤ºä½œè€…åœ¨ç¼–ç æ—¶å¦‚ä½•æŠŠæ–°é—®é¢˜å½’çº¦ä¸ºä¸€ç»„â€œå·²å‘½åçš„æŠ€å·§â€ã€‚ä½œè€…æ‹†è§£äº†è‡ªå·±å‡ ä¹ä¸å‡æ€ç´¢ç»™å‡ºçš„æ–¹æ¡ˆï¼ˆHistoryOptions + from_environment + positional DI ç­‰ï¼‰ï¼Œå¹¶å¼ºè°ƒè¿™æ˜¯ä¸€ç¯‡æè¿°æ€§â€œæ€ç»´è¿‡ç¨‹å‰–æâ€ï¼Œè€Œéç»™å‡ºå”¯ä¸€æ­£ç¡®ç­”æ¡ˆçš„è§„èŒƒæŒ‡å—ã€‚",
    "core_value": "æ ¸å¿ƒä»·å€¼åœ¨äºæŠŠâ€œç¼–ç¨‹çŸ¥è¯†/ç»éªŒâ€æŠ½è±¡ä¸ºå¯æ£€ç´¢ã€å¯è¿ç§»çš„â€œæ ¼è¨€å¼æŠ€å·§åº“â€ï¼Œè§£é‡Šé«˜æ‰‹å¦‚ä½•å¿«é€Ÿåšå‡ºè®¾è®¡å†³ç­–ã€‚å®ƒè§£å†³çš„æ˜¯éšæ€§çŸ¥è¯†éš¾ä»¥ä¼ æˆçš„é—®é¢˜ï¼šé€šè¿‡å‘½åä¸æº¯æºï¼Œè®©è¯»è€…å­¦ä¼šè¯†åˆ«ã€è®°å¿†å¹¶è·¨é¢†åŸŸè¿ç§»è®¾è®¡æ¨¡å¼ä¸ API è®¾è®¡ä¹ æƒ¯ã€‚",
    "tech_stack": [
      "Zig",
      "Zig æ ‡å‡†åº“ï¼ˆstd.process.Environ.Map / IOï¼‰",
      "API è®¾è®¡",
      "ä¾èµ–æ³¨å…¥ï¼ˆpositional DIï¼‰",
      "é…ç½®/Options æ¨¡å¼"
    ],
    "recommendation": "å€¼å¾—å…³æ³¨åœ¨äºå®ƒæä¾›äº†å¯å¤ç”¨çš„â€œå…ƒæŠ€èƒ½â€ï¼šå¦‚ä½•æŠŠé›¶æ•£ç»éªŒæ•´ç†æˆå¯è°ƒç”¨çš„å¿ƒæ™ºæ ‡ç­¾ï¼Œå¹¶åœ¨æ–°è¯­è¨€/æ–°çº¦æŸä¸‹å¿«é€Ÿäº§å‡ºæ›´å¯ç»´æŠ¤çš„æ¥å£è®¾è®¡ã€‚å¯¹åšåº“è®¾è®¡ã€ä»£ç è¯„å®¡ã€ä»¥åŠå¸Œæœ›æå‡æ¶æ„ç›´è§‰çš„å·¥ç¨‹å¸ˆæœ‰ç›´æ¥å¯å‘ã€‚",
    "score": 86.0,
    "_source_item": {
      "title": "Programming Aphorisms",
      "content": "Programming Aphorisms\nFeb 11, 2026\nA meta programming post â€” looking at my thought process when coding\nand trying to pin down what is programming â€œknowledgeâ€. Turns out, a\nsignificant fraction of that is just reducing new problems to a\nvocabulary of known tricks. This is a personal, descriptive post, not\na prescriptive post for you.\nIt starts with a question posted on Ziggit. The background here is\nthat Zig is in the process of removing ambient IO capabilities.\nCurrently, you can access program environment from anywhere via\nstd.process.getEnvVarOwned\n.\nIn the next Zig version, youâ€™ll have to thread\nstd.process.Environ.Map\nfrom main down to every routine that needs access to the environment.\nIn this userâ€™s case, they have a\nreadHistory\nfunction\nwhich used to look up the path to the history file in the environment,\nand they are wondering how to best model that in the new Zig. The\noptions on the table are:\npub\nfn\nreadHistory\n(\nio: std.Io,\nalloc: Allocator,\nfile: std.Io.File,\n) ReadHistoryError\n!\nvoid\n;\npub\nfn\nreadHistory\n(\nio: std.Io,\nalloc: Allocator,\nmaybe_environ_map: ?\n*\nstd.process.Environ.Map,\n) ReadHistoryError\n!\nvoid\n;\npub\nfn\nreadHistory\n(\nio: std.Io,\nalloc: Allocator,\nmaybe_absolute_path: ?[]\nconst\nu8\n,\nmaybe_environ_map: ?\n*\nstd.process.Environ.Map,\n) ReadHistoryError\n!\nvoid\n;\nMy starting point would instead be this:\npub\nconst\nHistoryOptions =\nstruct\n{\nfile: []\nconst\nu8\n,\npub\nfn\nfrom_environment\n(\nenvironment:\n*\nconst\nstd.process.Environ.Map,\n) HistoryOptions;\n};\npub\nfn\nreadHistory\n(\nio: std.Io,\ngpa: Allocator,\noptions: HistoryOptions,\n) ReadHistoryError\n!\nvoid\n;\nIn terms of meta programming, what I find fascinating is that this,\nfor me, is both immediate (I donâ€™t have to think about it), but also\nis clearly decomposable into multiple factoids Iâ€™ve accumulated\nbefore. Hereâ€™s a deconstruction of what I did here, the verbal\nâ€œlabelsâ€ I use to think about what I did, and where I had learned to\ndo that:\nFirst\n, I â€œraised the abstraction levelâ€ by giving\nit\na name and a type (\nHistoryOptions\n). This is a rare\ntransformation which I learned and named myself. Naming is important\nfor my thinking and communicating process. â€œLetâ€™s raise abstraction\nlevelâ€ is a staple code review comment of mine.\nSecond\n, I avoided â€œmidlayer mistakeâ€ by making sure that\nevery aspect of options is user-configurable. Easy to do in Zig, where\nall fields are public. I learned about\nmidlayer mistake\nfrom a\nGitHub comment by\nJosh Triplett\n.\nThird\n, I provided a â€œshortcutâ€, the\nfrom_environment\nconvenience function that cuts across abstraction layers. I learned\nthe â€œshortcutâ€ aphorism from\nDjango Views â€” The Right Way\n.\nGermane to the present article, I read that post a decade after I had\ntouched Django the last time. It was useless to me on the object\nlevel. On the meta level, reading the article solidified and\nnamed\nseveral programming tricks for me. See reverberations\nin\nHow to Make a ğŸ’¡?\n.\nFourth\n, I instinctively renamed\nalloc\nto â€œgpaâ€\n(in opposition to â€œarenaâ€), the naming I spotted in the Zig compiler.\nFifth\n, I named the configuration parameter â€œoptionsâ€, not\nconfig\n,\nprops\nor\nparams\n, a\nnaming scheme I learned at TigerBeetle.\nSixth\n, I made sure that the signature follows â€œpositional DIâ€\nscheme. Arguments that are dependencies, resources with unique types\nare injected positionally (and have canonical names like\nio\nor\ngpa\n). Arguments that\ndirectly\nvary the behavior of function (as opposed to affecting transitive\ncallees) are passed by name, in the\nOptions\nstruct.\nTo be specific, I donâ€™t claim that my snippet is the right way to do\nthis! I have no idea, as I donâ€™t have access to the full context.\nRather, if I were\nactually\nsolving the problem, the snippet\nabove would be my initial starting point for further iteration.\nNote that I also donâ€™t explain\nwhy\nI am doing the above six\nthings, I only name them and point at the origin. Actually explaining\nthe\nwhy\nwould take a blog post of its own for every one of\nthem.\nAnd this is I think the key property of my thought process â€” I have a\nbag of tricks, where the tricks are named. Inside my mind, this label\npoints both to the actual trick (code to type), as well as a\njustification for it (in what context that would be a good trick to\nuse).\nAnd I use these tricks all the time, literally! Just answering in\npassing to a forum comment makes me grab a handful! A lot of my\nknowledge is structured like a book of coding aphorisms.\nMeta meta â€” how come I have acquired all those tricks? I read\nvoraciously, random commits, issues, jumping enthusiastically into\nrabbit holes and going on wiki trips. The key skill here is\nrecognizing an aphorism once you see it. Reading Ziggit is part of\ntrick-acquisition routine for me. Having learned the trick, I remember\nit, where â€œrememberingâ€ is an act of active recall at the opportune\nmoment. This recall powers â€œhorizontal gene transferâ€ across domains,\nstealing shortcuts from Django and midlayer mistake from the kernel.\nDid you notice that applying â€œhorizontal gene transferâ€ to the domain\nof software engineering tacit knowledge is horizontal gene transfer?\nWhen entering a new domain, I actively seek out the missing tricks. I\nam relatively recent in Zig, but all the above tricks are either Zig\nnative, or at least Zig adapted. Every once in a while, I â€œinventâ€ a\ntrick of my own. For example, â€œpositional DIâ€ is something I only\nverbalized last year. This doesnâ€™t mean I hadnâ€™t been doing that\nbefore, just that the activity wasnâ€™t mentally labeled as a separate\nthing you can deliberately do. I had the idea, now I also have an\naphorism.",
      "description": "",
      "id": null,
      "short_id": null,
      "url": "https://matklad.github.io/2026/02/11/programming-aphorisms.html",
      "score": "22",
      "tags": "zig",
      "domain": "matklad.github.io",
      "author": "fanf",
      "author_url": "fanf",
      "time": "9 hours ago",
      "comments_text": "3 comments",
      "comments_url": "3 comments",
      "description_hint": null,
      "source": "Lobsters"
    }
  },
  "cached_at": "2026-02-12T05:06:13.757940"
}