{
  "url": "https://blog.fabiomanganiello.com/article/webmentions-with-batteries-included",
  "summary": {
    "summary": "文章介绍了 Webmention 这一去中心化的站点互相“通知与回链”机制：当 A 站发布内容引用了 B 站文章时，可向 B 站发送 Webmention，B 站验证后将其展示为评论/引用/点赞等互动信息。作者认为 Webmention 相比 ActivityPub 更轻量、纯点对点，并借助 Microformats 扩展到多种语义互动。为降低落地成本，作者实现了一个“开箱即用”的 Python 库，提供接收/发送、存储、监控静态文件、框架绑定与回调扩展等能力。",
    "core_value": "把“概念简单但实现繁琐”的 Webmention 协议工程化封装成可集成的库，减少端点暴露、验证、解析语义、存储与发送等细节工作量。让个人站点/静态站点在不依赖第三方评论系统或社交平台的情况下，获得可控的跨站互动能力。",
    "tech_stack": [
      "Python",
      "Webmention",
      "Microformats",
      "FastAPI",
      "Flask",
      "SQLAlchemy",
      "SQLite",
      "HTTP(Link header)",
      "Filesystem monitoring",
      "Static site content (HTML/Markdown/text)"
    ],
    "recommendation": "如果你在做个人博客/独立站/静态内容站点，这个库提供了从端点注册、自动发现与发送到存储与回调扩展的一整套“电池齐全”方案，能快速把去中心化互动落地。对希望实践 POSSE、减少对中心化平台依赖、同时又不想引入 ActivityPub 复杂度的团队尤其值得关注。",
    "score": 86.0,
    "_source_item": {
      "title": "Webmentions with batteries included",
      "content": "I have been a quite strong advocate of\nWebmentions\nfor a long time.\nThe idea is simple and powerful, and very consistent with the decentralized\nPOSSE\napproach to content syndication.\nSuppose that Alice finds an interesting article on Bob's website, at\nhttps://bob.com/article\n.\nShe writes a comment about it on her own website, at\nhttps://alice.com/comment\n.\nIf both Alice's and Bob's websites support Webmentions, then their websites will both advertise an e.g.\nPOST /webmentions\nendpoint.\nWhen Alice publishes her comment, her website will send a Webmention to Bob's website, with the source URL (\nhttps://alice.com/comment\n) and the target URL (\nhttps://bob.com/article\n).\nBob's website will receive the Webmention, verify that the source URL actually mentions the target URL, and then display the comment on the article page.\nNo 3rd-party commenting system. No intermediate services. No social media login buttons. No ad-hoc comment storage and moderation solutions. Just a simple, decentralized, peer-to-peer mechanism based on existing Web standards.\nThis is an alternative (and complementary) approach to federation mechanisms like\nActivityPub\n, which are very powerful but also quite complex to implement, as implementations must deal with concepts such as actors, relays, followers, inboxes, outboxes, and so on.\nIt is purely peer-to-peer, based on existing Web infrastructure, and with no intermediate actors or services.\nMoreover, thanks to\nMicroformats\n, Webmentions can be used to share any kind of content, not just comments: likes, reactions, RSVPs, media, locations, events, and so on.\nHowever, while the concept is simple, implementing Webmentions support from scratch can be a bit cumbersome, especially if you want to do it right and support\nall the semantic elements\n.\nI have thus proceeded to\nimplement a simple Python library\n(but more bindings are\non the backlog\n) that can be easily integrated into any website, and that takes care of all the details of the Webmentions protocol implementation. You only have to worry about writing good semantic HTML, and rendering Webmention objects in your pages.\nQuick start\nIf you use FastAPI or Flask, serve your website as static files and you're ok to use an SQLAlchemy engine to store Webmentions, you can get started in a few lines of code.\n#\nFor\nFastAPI\nbindings\npip\ninstall\n\"webmentions[db,file,fastapi]\"\n#\nFor\nFlask\nbindings\npip\ninstall\n\"webmentions[db,file,flask]\"\nBase implementation:\n1\nimport\nos\n2\n3\nfrom\nwebmentions\nimport\nWebmentionsHandler\n4\nfrom\nwebmentions\n.\nstorage\n.\nadapters\n.\ndb\nimport\ninit_db_storage\n5\nfrom\nwebmentions\n.\nserver\n.\nadapters\n.\nfastapi\nimport\nbind_webmentions\n6\nfrom\nwebmentions\n.\nstorage\n.\nadapters\n.\nfile\nimport\nFileSystemMonitor\n7\n8\n# This should match the public URL of your website\n9\nbase_url\n=\n\"\nhttps://example.com\n\"\n10\n11\n# The directory that serves your static articles/posts.\n12\n# HTML, Markdown and plain text are supported\n13\nstatic_dir\n=\n\"\n/srv/html/articles\n\"\n14\n15\n# A function that takes a path to a created/modified/deleted text/* file\n16\n# and maps it to a URL on the Web server to be used as the Webmention source\n17\ndef\npath_to_url\n(\npath\n:\nstr\n)\n-\n>\nstr\n:\n18\n# Convert path (absolute) to a path relative to static_dir\n19\n# and drop the extension.\n20\n# For example, /srv/http/articles/2022/01/01/article.md\n21\n# becomes /2022/01/01/article\n22\npath\n=\nos\n.\npath\n.\nrelpath\n(\npath\n,\nstatic_dir\n)\n.\nrsplit\n(\n\"\n.\n\"\n,\n1\n)\n[\n0\n]\n.\nlstrip\n(\n\"\n/\n\"\n)\n23\n# Convert the path to a URL on the Web server\n24\n# For example, /2022/01/01/article\n25\n# becomes https://example.com/articles/2022/01/01/article\n26\nreturn\nf\n\"\n{\nbase_url\n.\nrstrip\n(\n'\n/\n'\n)\n}\n/articles/\n{\npath\n}\n\"\n27\n28\n##### For FastAPI\n29\n30\nfrom\nfastapi\nimport\nFastAPI\n31\nfrom\nwebmentions\n.\nserver\n.\nadapters\n.\nfastapi\nimport\nbind_webmentions\n32\n33\napp\n=\nFastAPI\n(\n)\n34\n35\n##### For Flask\n36\n37\nfrom\nflask\nimport\nFlask\n38\nfrom\nwebmentions\n.\nserver\n.\nadapters\n.\nflask\nimport\nbind_webmentions\n39\n40\napp\n=\nFlask\n(\n__name__\n)\n41\n42\n# ...Initialize your Web app as usual...\n43\n44\n# Create a Webmention handler\n45\n46\nhandler\n=\nWebmentionsHandler\n(\n47\nstorage\n=\ninit_db_storage\n(\nengine\n=\n\"\nsqlite:////tmp/webmentions.db\n\"\n)\n,\n48\nbase_url\n=\nbase_url\n,\n49\n)\n50\n51\n# Bind Webmentions to your app\n52\nbind_webmentions\n(\napp\n,\nhandler\n)\n53\n54\n# Create and start the filesystem monitor before running your app\n55\nwith\nFileSystemMonitor\n(\n56\nroot_dir\n=\nstatic_dir\n,\n57\nhandler\n=\nhandler\n,\n58\nfile_to_url_mapper\n=\npath_to_url\n,\n59\n)\nas\nmonitor\n:\n60\napp\n.\nrun\n(\n.\n.\n.\n)\nThis will:\nRegister a\nPOST /webmentions\nendpoint to receive Webmentions\nAdvertise the Webmentions endpoint in every\ntext/*\nresponse provided by the server\nExpose a\nGET /webmentions\nendpoint to list Webmentions (takes\nresource\nURL and\ndirection\n(\nin\nor\nout\n) query parameters)\nStore Webmentions in a database (using SQLAlchemy)\nMonitor\nstatic_dir\nfor changes to HTML or text files, automatically parse them to extract Webmention targets and sources, and send Webmentions when new targets are found\nGeneric Web framework setup\nIf you don't use FastAPI or Flask, or you want a higher degree of customization, you can still use the library by implementing and advertising your own Webmentions endpoint, which in turn will simply call\nWebmentionsHandler.process_incoming_webmention\n.\nYou will also have advertise the Webmentions endpoint in your responses, either through:\nA\nLink\nheader (with a value in the format\n<https://example.com/webmentions>; rel=\"webmention\"\n)\nA\n<link>\nor\n<a>\nelement in the HTML head or body (in the format\n<link rel=\"webmention\" href=\"https://example.com/webmentions\">\n)\nAn example is provided\nin the documentation\n.\nGeneric storage setup\nIf you don't want to use SQLAlchemy, you can implement your own storage by implementing the\nWebmentionsStorage\ninterface (namely the\nstore_webmention\n,\nretrieve_webmentions\n, and\ndelete_webmention\nmethods), then pass that to the\nWebmentionsHandler\nconstructor.\nAn example is provided\nin the documentation\n.\nManual handling of outgoing Webmentions\nThe\nFileSystemMonitor\napproach is quite convenient if you serve your website (or a least the mentionable parts of it) as static files.\nHowever, if you have a more dynamic website (with posts and comments stored on e.g. a database), or you want to have more control over when Webmentions are sent, you can also call the\nWebmentionsHandler.process_outgoing_webmentions\nmethod whenever a post or comment is published, updated or deleted, to trigger the sending of Webmentions to the referenced targets.\nAn example is provided\nin the documentation\n.\nSubscribe to mention events\nYou may want to add your custom callbacks when a Webmention is sent or received - for example to send notifications to your users when some of their content is mentioned, or to keep track of the number of mentions sent by your pages, or to perform any automated moderation or filtering when mentions are processed etc.\nThis can be easily achieved by providing custom callback functions (\non_mention_processed\nand\non_mention_deleted\n) to the\nWebmentionsHandler\nconstructor, and both take a single\nWebmention\nobject as a parameter.\nAn example is provided\nin the documentation\n.\nFiltering and moderation\nThis library is intentionally agnostic about filtering and moderation, but it provides you with the means to implement your own filtering and moderation logic through the\non_mention_processed\nand\non_mention_deleted\ncallbacks.\nBy default all received Webmentions are stored with\nWebmentionStatus.CONFIRMED\nstatus.\nThis can be changed by setting the\ninitial_mention_status\nparameter of the\nWebmentionsHandler\nconstructor to\nWebmentionStatus.PENDING\n, which will cause all received Webmentions to be stored but not visible on the website until they are manually confirmed by an administrator.\nYou can then use the\non_mention_processed\ncallback to implement your own logic to either notify the administrator of new pending mentions, or to automatically confirm them based on some criteria.\nA minimal example is provided\nin the documentation\n.\nMake your pages mentionable\nWithout good semantic HTML, Webmentions will be quite minimal. They will still work, but they will probably be rendered simply as a source URL and a creation timestamp.\nThe Webmention specification is intentionally simple, in that the\nPOST\nendpoint only expects a source URL and a target URL. The rest of the information about the mention (the author, the content, the type of mention, any attachments, and so on) is all derived from the source URL, by parsing the HTML of the source page and extracting the relevant Microformats.\nWhile the Microformats2 specification is quite flexible and a work-in-progress, there are a few basic elements whose usage is recommended to make the most out of Webmentions.\nA complete example with a semantic-aware HTML article is provided\nin the documentation\n.\nRendering mentions on your pages\nFinally, the last step is to render the received Webmentions on your pages.\nA\nWebmentionsHandler.render_webmentions\nhelper is provided to automatically generate a list of safe\nMarkup\nobjects,\nwhich you can then render in your templates.\nAn\nexample\nimplementation\nis provided in the documentation.\nFor more customizing rendering, a\nreference Jinja\ntemplate\nis also provided in the documentation.\nCurrent implementations\nSo far the library is used in\nmadblog\n, a minimal zero-database Markdown-based blogging engine I maintain, which powers both\nmy personal blog\nand the\nPlatypush blog\n.\nYou can see some Webmentions in action on\nsome of my blog posts\n.\nAnd, if you include a link to any article of mine in your website, and your website supports Webmentions (for example\nthere is a Wordpress plugin\n), you should see the mention appear in the comments of the article page.\nLinks",
      "description": "",
      "id": null,
      "short_id": null,
      "url": "https://blog.fabiomanganiello.com/article/webmentions-with-batteries-included",
      "score": "21",
      "tags": "api",
      "domain": "blog.fabiomanganiello.com",
      "author": "blacklight",
      "author_url": "blacklight",
      "time": "16 hours ago",
      "comments_text": "11 comments",
      "comments_url": "11 comments",
      "description_hint": null,
      "source": "Lobsters"
    }
  },
  "cached_at": "2026-02-12T05:06:13.757618"
}